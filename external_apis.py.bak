import requests
import json
import logging
import os
import math
import pandas as pd
from config import OUTPUT_DIR

# Initialiser le logging pour ce module
logger = logging.getLogger(__name__)

# Configuration par d√©faut des API externes
DEFAULT_EXTERNAL_API_CONFIG = {
    # OpenWeatherMap API
    "openweathermap": {
        "api_key": "",  # √Ä remplir avec votre cl√© API
        "api_url": "https://api.openweathermap.org/data/2.5/",
        "units": "metric",  # Unit√©s m√©triques (Celsius, m/s, etc.)
        "lang": "fr",  # Langue fran√ßaise
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # OpenWeatherMap Air Pollution API
    "openweathermap_air_pollution": {
        "api_key": "",  # √Ä remplir avec votre cl√© API
        "api_url": "https://api.openweathermap.org/data/2.5/air_pollution",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # SoilGrids API
    "soilgrids": {
        "api_url": "https://rest.isric.org/soilgrids/v2.0/",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # INSEE API
    "insee": {
        "api_key": "",  # √Ä remplir avec votre cl√© API
        "api_secret": "",  # √Ä remplir avec votre secret API
        "api_url": "https://api.insee.fr/",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # Banque Mondiale API
    "worldbank": {
        "api_url": "https://api.worldbank.org/v2/",
        "format": "json",
        "country": "MA",  # Code pays pour le Maroc
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # OpenStreetMap / Overpass API
    "openstreetmap": {
        "api_url": "https://overpass-api.de/api/interpreter",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # Copernicus Climate Data Store API
    "copernicus": {
        "api_key": "",  # √Ä remplir avec votre cl√© API
        "api_url": "https://cds.climate.copernicus.eu/api/v2/",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # Global Biodiversity Information Facility (GBIF) API
    "gbif": {
        "api_url": "https://api.gbif.org/v1/",
        "enabled": True  # Activer/d√©sactiver cette API
    },
    # NASA Earth Data API
    "nasa": {
        "api_key": "",  # √Ä remplir avec votre cl√© API NASA
        "api_url": "https://api.nasa.gov/",
        "enabled": True  # Activer/d√©sactiver cette API
    }
}

# Charger les configurations depuis le fichier external_api_config.json
def load_external_api_config():
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "external_api_config.json")
    config = DEFAULT_EXTERNAL_API_CONFIG.copy()
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                saved_config = json.load(f)
                
                # Mettre √† jour la configuration avec les valeurs sauvegard√©es
                for provider in config.keys():
                    if provider in saved_config:
                        for key, value in saved_config[provider].items():
                            if key in config[provider]:
                                config[provider][key] = value
                                
            logger.info("Configurations des API externes charg√©es avec succ√®s depuis external_api_config.json")
        except Exception as e:
            logger.error(f"Erreur lors du chargement des configurations API externes: {str(e)}")
    else:
        logger.warning("Fichier external_api_config.json non trouv√©, utilisation des configurations par d√©faut")
    
    return config

# Charger les configurations au d√©marrage
EXTERNAL_API_CONFIG = load_external_api_config()

class ExternalAPIs:
    """Classe pour interagir avec diff√©rentes API externes pour collecter des donn√©es environnementales."""
    
    def __init__(self):
        """Initialise les API externes."""
        self.config = EXTERNAL_API_CONFIG
    
    def get_weather_data(self, lat, lon):
        """R√©cup√®re les donn√©es m√©t√©orologiques pour des coordonn√©es donn√©es via OpenWeatherMap.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Donn√©es m√©t√©orologiques ou None en cas d'erreur
        """
        try:
            api_key = self.config["openweathermap"]["api_key"]
            url = "https://api.openweathermap.org/data/2.5/weather"
            params = {
                "lat": lat,
                "lon": lon,
                "appid": api_key,
                "units": "metric",
                "lang": "fr"
            }
            response = requests.get(url, params=params, timeout=10)
            if response.status_code != 200:
                logger.warning(f"M√©t√©o: {response.status_code} - {response.text}")
                return None

            data = response.json()

            # ‚úÖ Extraction correcte des donn√©es
            return {
                "Temp√©rature": (data["main"]["temp"], "¬∞C"),
                "Humidit√©": (data["main"]["humidity"], "%"),
                "Pression": (data["main"]["pressure"], "hPa"),
                "Vent": (data["wind"]["speed"], "m/s"),
                "Ciel": (data["weather"][0]["description"], "")
            }
        except Exception as e:
            logger.error(f"Erreur m√©t√©o: {e}")
            return None

    
    def get_air_quality_data(self, lat, lon):
        """R√©cup√®re les donn√©es de qualit√© de l'air pour des coordonn√©es donn√©es via OpenWeatherMap Air Pollution.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Donn√©es de qualit√© de l'air ou None en cas d'erreur
        """
        try:
            api_key = self.config["openweathermap"]["api_key"]
            url = "https://api.openweathermap.org/data/2.5/air_pollution"
            params = {
                "lat": lat,
                "lon": lon,
                "appid": api_key
            }
            response = requests.get(url, params=params, timeout=10)
            if response.status_code != 200:
                logger.warning(f"Air: {response.status_code} - {response.text}")
                return None

            data = response.json()["list"][0]["components"]

            return {
                "AQI": (response.json()["list"][0]["main"]["aqi"], ""),
                "PM2.5": (data["pm2_5"], "¬µg/m¬≥"),
                "PM10": (data["pm10"], "¬µg/m¬≥"),
                "NO‚ÇÇ": (data["no2"], "¬µg/m¬≥"),
                "SO‚ÇÇ": (data["so2"], "¬µg/m¬≥"),
                "CO": (data["co"], "¬µg/m¬≥")
            }
        except Exception as e:
            logger.error(f"Erreur air: {e}")
            return None

    
    def _interpret_aqi(self, aqi):
        """Interpr√®te l'indice de qualit√© de l'air selon les normes US EPA.
        
        Args:
            aqi (int): Indice de qualit√© de l'air (AQI US)
            
        Returns:
            str: Interpr√©tation de l'AQI
        """
        if aqi <= 50:
            return "Bon - La qualit√© de l'air est satisfaisante et la pollution pr√©sente peu ou pas de risque"
        elif aqi <= 100:
            return "Mod√©r√© - La qualit√© de l'air est acceptable, mais peut pr√©senter un risque pour certaines personnes sensibles"
        elif aqi <= 150:
            return "Malsain pour les groupes sensibles - Les personnes sensibles peuvent subir des effets sur la sant√©"
        elif aqi <= 200:
            return "Malsain - Tout le monde peut commencer √† ressentir des effets sur la sant√©"
        elif aqi <= 300:
            return "Tr√®s malsain - Avertissements sanitaires, tout le monde peut subir des effets plus graves"
        else:
            return "Dangereux - Alerte sanitaire: tout le monde peut subir des effets graves sur la sant√©"
    
    def _describe_pollutant(self, pollutant):
        """Fournit une description du polluant principal.
        
        Args:
            pollutant (str): Code du polluant principal
            
        Returns:
            str: Description du polluant
        """
        descriptions = {
            # Anciens codes AirVisual
            "p2": "PM2.5 - Particules fines de diam√®tre inf√©rieur √† 2,5 microm√®tres, dangereuses car elles p√©n√®trent profond√©ment dans les poumons",
            "p1": "PM10 - Particules de diam√®tre inf√©rieur √† 10 microm√®tres, pouvant causer des probl√®mes respiratoires",
            "o3": "Ozone (O3) - Polluant secondaire form√© par r√©action photochimique, irritant pour les voies respiratoires",
            "n2": "Dioxyde d'azote (NO2) - Gaz irritant produit principalement par la combustion, affecte le syst√®me respiratoire",
            "s2": "Dioxyde de soufre (SO2) - Gaz irritant produit par la combustion de combustibles fossiles, cause des probl√®mes respiratoires",
            "co": "Monoxyde de carbone (CO) - Gaz toxique inodore produit par combustion incompl√®te, r√©duit la capacit√© du sang √† transporter l'oxyg√®ne",
            
            # Nouveaux codes OpenWeatherMap
            "PM2.5": "PM2.5 - Particules fines de diam√®tre inf√©rieur √† 2,5 microm√®tres, dangereuses car elles p√©n√®trent profond√©ment dans les poumons",
            "PM10": "PM10 - Particules de diam√®tre inf√©rieur √† 10 microm√®tres, pouvant causer des probl√®mes respiratoires",
            "O3": "Ozone (O3) - Polluant secondaire form√© par r√©action photochimique, irritant pour les voies respiratoires",
            "NO2": "Dioxyde d'azote (NO2) - Gaz irritant produit principalement par la combustion, affecte le syst√®me respiratoire",
            "SO2": "Dioxyde de soufre (SO2) - Gaz irritant produit par la combustion de combustibles fossiles, cause des probl√®mes respiratoires",
            "CO": "Monoxyde de carbone (CO) - Gaz toxique inodore produit par combustion incompl√®te, r√©duit la capacit√© du sang √† transporter l'oxyg√®ne"
        }
        
        return descriptions.get(pollutant, f"Polluant inconnu: {pollutant}")
    
    def get_soil_data(self, lat, lon, properties=None, depth="0-5cm"):
        """
        R√©cup√®re plusieurs propri√©t√©s du sol via SoilGrids en utilisant l'endpoint properties/query.
        Si cet endpoint √©choue, essaie l'endpoint classification/query comme solution de secours.

        Args:
            lat (float): Latitude.
            lon (float): Longitude.
            properties (list, optional): Liste des propri√©t√©s SoilGrids √† r√©cup√©rer. 
                                     Par d√©faut: ["phh2o", "clay", "sand", "soc", "bdod"].
            depth (str, optional): Profondeur d'analyse. Par d√©faut: "0-5cm".

        Returns:
            dict: Dictionnaire avec les noms de param√®tres normalis√©s et leurs valeurs.
        """
        if properties is None:
            properties = ["phh2o", "clay", "sand", "soc", "bdod"]

        # üîß Arrondir les coordonn√©es pour √©viter les erreurs
        try:
            lat = round(float(lat), 6)
            lon = round(float(lon), 6)
        except (TypeError, ValueError) as e:
            logger.error(f"SoilGrids: Erreur de conversion des coordonn√©es - {str(e)}")
            return {}

        # Normalisation des noms de param√®tres et unit√©s
        PROPERTY_MAP = {
            "phh2o": ("pH du sol", "pH"),
            "clay": ("Teneur en argile", "%"),
            "sand": ("Teneur en sable", "%"),
            "soc": ("Carbone organique du sol", "g/kg"),
            "bdod": ("Densit√© apparente", "kg/dm¬≥")
        }

        # Initialiser le dictionnaire de r√©sultats
        soil_data = {}
        for prop_code in properties:
            norm_name, unit = PROPERTY_MAP.get(prop_code, (prop_code, ""))
            soil_data[norm_name] = ("N/A", unit)

        try:
            # üõë Ajouter un d√©lai pour ne pas surcharger le serveur
            import time
            time.sleep(1)
            
            # Essayer d'abord l'endpoint properties/query pour obtenir les valeurs exactes
            properties_url = "https://rest.isric.org/soilgrids/v2.0/properties/query"
            properties_params = {
                "lon": lon,
                "lat": lat,
                "property": properties,
                "depth": depth,
                "value": "mean"
            }
            
            logger.info(f"SoilGrids: Tentative d'utilisation de l'endpoint properties/query avec {properties_params}")
            properties_response = requests.get(properties_url, params=properties_params, timeout=15)
            
            # Si l'endpoint properties/query fonctionne, utiliser les valeurs exactes
            if properties_response.status_code == 200:
                logger.info("SoilGrids: Endpoint properties/query a r√©ussi, utilisation des valeurs exactes")
                data = properties_response.json()
                
                if "properties" in data and "layers" in data["properties"]:
                    for layer in data["properties"]["layers"]:
                        prop_name = layer["name"]
                        if prop_name in properties and "depths" in layer and len(layer["depths"]) > 0:
                            mean_value = layer["depths"][0]["values"].get("mean")
                            if mean_value is not None:
                                # Appliquer les facteurs de conversion si n√©cessaire
                                if prop_name == "phh2o":
                                    mean_value = mean_value / 10  # Convertir en pH r√©el
                                
                                norm_name, unit = PROPERTY_MAP.get(prop_name, (prop_name, ""))
                                soil_data[norm_name] = (str(round(mean_value, 2)), unit)
                                logger.info(f"SoilGrids: Valeur exacte pour {prop_name}: {mean_value} {unit}")
                
                return soil_data
            else:
                logger.warning(f"SoilGrids: L'endpoint properties/query a √©chou√© avec le code {properties_response.status_code}. Utilisation de l'endpoint classification/query comme solution de secours.")
            
            # Si l'endpoint properties/query √©choue, utiliser l'endpoint classification/query comme solution de secours
            url = "https://rest.isric.org/soilgrids/v2.0/classification/query"
            params = {
                "lon": lon,
                "lat": lat,
                "number_classes": 5  # Obtenir les 5 classes de sol les plus probables
            }
            
            response = requests.get(url, params=params, timeout=10)
            
            # üîç V√©rifier le code de statut
            if response.status_code != 200:
                logger.error(f"SoilGrids: {response.status_code} - {response.text}")
                return soil_data

            data = response.json()
            
            # D√©boguer la structure de la r√©ponse
            logger.info(f"SoilGrids: Structure de la r√©ponse: {json.dumps(data, indent=2)[:500]}...")

            # Extraire la classification du sol et les probabilit√©s
            soil_class = None
            soil_class_probability = 0
            soil_classes_info = []

            if "wrb_class_name" in data:
                soil_class = data.get("wrb_class_name")
                soil_class_probability = data.get("wrb_class_probability", 0)
                logger.info(f"SoilGrids: Classe de sol principale: {soil_class} (probabilit√©: {soil_class_probability})")
                
                # Collecter les informations sur toutes les classes de sol
                if "wrb_class_value" in data and "wrb_class_probability" in data:
                    soil_classes_info.append({
                        "class": soil_class,
                        "probability": soil_class_probability
                    })
                
                # Collecter les informations sur les classes alternatives
                if "wrb_class_value_other" in data and "wrb_class_probability_other" in data:
                    other_classes = data.get("wrb_class_name_other", [])
                    other_probs = data.get("wrb_class_probability_other", [])
                    
                    for i in range(min(len(other_classes), len(other_probs))):
                        soil_classes_info.append({
                            "class": other_classes[i],
                            "probability": other_probs[i]
                        })
                        logger.info(f"SoilGrids: Classe alternative {i+1}: {other_classes[i]} (probabilit√©: {other_probs[i]})")
                
                # Estimer les propri√©t√©s du sol en fonction de la classification
                estimated_properties = self._estimate_soil_properties(soil_class, soil_classes_info)
                
                # Mettre √† jour soil_data avec les estimations, mais indiquer qu'il s'agit d'estimations
                for prop_code in properties:
                    if prop_code in estimated_properties:
                        norm_name, unit = PROPERTY_MAP.get(prop_code, (prop_code, ""))
                        value = estimated_properties[prop_code]
                        soil_data[norm_name] = (f"{value} (estim√©)", unit)
                        logger.info(f"SoilGrids: Valeur estim√©e pour {prop_code}: {value} {unit}")
            else:
                logger.warning("SoilGrids: Classification du sol non trouv√©e dans la r√©ponse")
            
            return soil_data

        except requests.exceptions.Timeout:
            logger.error("SoilGrids: Timeout apr√®s 10 secondes")
        except requests.exceptions.ConnectionError:
            logger.error("SoilGrids: Probl√®me de connexion au serveur")
        except Exception as e:
            logger.error(f"SoilGrids: Erreur inattendue - {str(e)}")
        
        return soil_data
        
    def _estimate_soil_properties(self, soil_class, soil_classes_info):
        """
        Estime les propri√©t√©s du sol en fonction de la classification WRB.
        
        Args:
            soil_class (str): Classe de sol principale selon WRB.
            soil_classes_info (list): Liste des classes de sol avec leurs probabilit√©s.
            
        Returns:
            dict: Propri√©t√©s estim√©es du sol.
        """
        # Valeurs par d√©faut pour les diff√©rentes classes de sol
        # Ces valeurs sont des estimations bas√©es sur la litt√©rature scientifique
        soil_properties_by_class = {
            "Acrisols": {"phh2o": 5.2, "clay": 35, "sand": 40, "soc": 15, "bdod": 1.3},
            "Alisols": {"phh2o": 4.8, "clay": 40, "sand": 30, "soc": 20, "bdod": 1.2},
            "Andosols": {"phh2o": 6.0, "clay": 15, "sand": 45, "soc": 80, "bdod": 0.8},
            "Arenosols": {"phh2o": 6.5, "clay": 5, "sand": 90, "soc": 5, "bdod": 1.5},
            "Calcisols": {"phh2o": 8.0, "clay": 25, "sand": 50, "soc": 10, "bdod": 1.4},
            "Cambisols": {"phh2o": 6.5, "clay": 25, "sand": 40, "soc": 20, "bdod": 1.3},
            "Chernozems": {"phh2o": 7.0, "clay": 30, "sand": 35, "soc": 60, "bdod": 1.2},
            "Cryosols": {"phh2o": 6.0, "clay": 20, "sand": 45, "soc": 40, "bdod": 1.1},
            "Durisols": {"phh2o": 7.5, "clay": 30, "sand": 45, "soc": 8, "bdod": 1.5},
            "Ferralsols": {"phh2o": 5.5, "clay": 60, "sand": 20, "soc": 25, "bdod": 1.2},
            "Fluvisols": {"phh2o": 6.8, "clay": 25, "sand": 40, "soc": 30, "bdod": 1.3},
            "Gleysols": {"phh2o": 6.0, "clay": 35, "sand": 30, "soc": 40, "bdod": 1.2},
            "Gypsisols": {"phh2o": 7.8, "clay": 20, "sand": 60, "soc": 5, "bdod": 1.4},
            "Histosols": {"phh2o": 5.5, "clay": 10, "sand": 20, "soc": 200, "bdod": 0.3},
            "Kastanozems": {"phh2o": 7.2, "clay": 30, "sand": 40, "soc": 40, "bdod": 1.3},
            "Leptosols": {"phh2o": 6.5, "clay": 20, "sand": 50, "soc": 15, "bdod": 1.4},
            "Lixisols": {"phh2o": 6.0, "clay": 30, "sand": 45, "soc": 10, "bdod": 1.4},
            "Luvisols": {"phh2o": 6.5, "clay": 35, "sand": 30, "soc": 20, "bdod": 1.3},
            "Nitisols": {"phh2o": 5.8, "clay": 50, "sand": 20, "soc": 25, "bdod": 1.2},
            "Phaeozems": {"phh2o": 6.8, "clay": 30, "sand": 35, "soc": 50, "bdod": 1.2},
            "Planosols": {"phh2o": 6.0, "clay": 40, "sand": 30, "soc": 15, "bdod": 1.4},
            "Plinthosols": {"phh2o": 5.5, "clay": 45, "sand": 30, "soc": 15, "bdod": 1.3},
            "Podzols": {"phh2o": 4.5, "clay": 10, "sand": 80, "soc": 30, "bdod": 1.3},
            "Regosols": {"phh2o": 6.5, "clay": 15, "sand": 60, "soc": 10, "bdod": 1.4},
            "Solonchaks": {"phh2o": 8.5, "clay": 30, "sand": 45, "soc": 10, "bdod": 1.4},
            "Solonetz": {"phh2o": 8.0, "clay": 35, "sand": 40, "soc": 15, "bdod": 1.4},
            "Stagnosols": {"phh2o": 6.0, "clay": 40, "sand": 25, "soc": 30, "bdod": 1.3},
            "Technosols": {"phh2o": 7.0, "clay": 20, "sand": 50, "soc": 20, "bdod": 1.3},
            "Umbrisols": {"phh2o": 5.5, "clay": 25, "sand": 45, "soc": 50, "bdod": 1.1},
            "Vertisols": {"phh2o": 7.0, "clay": 60, "sand": 15, "soc": 25, "bdod": 1.3}
        }
        
        # Valeurs par d√©faut si la classe de sol n'est pas reconnue
        default_properties = {"phh2o": 6.5, "clay": 25, "sand": 40, "soc": 20, "bdod": 1.3}
        
        # Si la classe de sol principale est reconnue, utiliser ses valeurs
        if soil_class in soil_properties_by_class:
            return soil_properties_by_class[soil_class]
        
        # Si la classe principale n'est pas reconnue mais qu'il y a des classes alternatives
        if soil_classes_info and len(soil_classes_info) > 0:
            # Calculer une moyenne pond√©r√©e des propri√©t√©s en fonction des probabilit√©s
            weighted_properties = {"phh2o": 0, "clay": 0, "sand": 0, "soc": 0, "bdod": 0}
            total_probability = 0
            
            for class_info in soil_classes_info:
                class_name = class_info.get("class")
                probability = class_info.get("probability", 0)
                
                if class_name in soil_properties_by_class and probability > 0:
                    for prop, value in soil_properties_by_class[class_name].items():
                        weighted_properties[prop] += value * probability
                    total_probability += probability
            
            # Si au moins une classe reconnue a √©t√© trouv√©e
            if total_probability > 0:
                for prop in weighted_properties:
                    weighted_properties[prop] = round(weighted_properties[prop] / total_probability, 2)
                return weighted_properties
        
        # Si aucune classe reconnue n'a √©t√© trouv√©e, utiliser les valeurs par d√©faut
        logger.warning(f"SoilGrids: Classe de sol '{soil_class}' non reconnue, utilisation des valeurs par d√©faut")
        return default_properties
    
    def _interpret_clay_content(self, clay_percentage):
        """Interpr√®te la teneur en argile du sol.
        
        Args:
            clay_percentage (float): Pourcentage d'argile
            
        Returns:
            str: Interpr√©tation de la teneur en argile
        """
        # V√©rifier si clay_percentage est None avant de faire des comparaisons
        if clay_percentage is None:
            return "Teneur moyenne en argile (estim√©)"
            
        if clay_percentage < 10:
            return "Sol sableux - Drainage rapide, faible r√©tention d'eau et de nutriments"
        elif clay_percentage < 25:
            return "Sol limoneux - Bon √©quilibre entre drainage et r√©tention"
        elif clay_percentage < 40:
            return "Sol argileux - Bonne r√©tention d'eau et de nutriments, mais drainage lent"
        else:
            return "Sol tr√®s argileux - Forte r√©tention d'eau, risque de compaction et drainage tr√®s lent"
    
    def _interpret_organic_carbon(self, soc):
        """Interpr√®te la teneur en carbone organique du sol.
        
        Args:
            soc (float): Teneur en carbone organique (g/kg)
            
        Returns:
            str: Interpr√©tation de la teneur en carbone organique
        """
        # V√©rifier si soc est None avant de faire des comparaisons
        if soc is None:
            return "Teneur moyenne en carbone organique (estim√©)"
            
        if soc < 10:
            return "Tr√®s faible - Sol pauvre en mati√®re organique, fertilit√© r√©duite"
        elif soc < 20:
            return "Faible - Teneur limit√©e en mati√®re organique"
        elif soc < 40:
            return "Moyen - Teneur acceptable en mati√®re organique"
        elif soc < 60:
            return "√âlev√© - Bonne teneur en mati√®re organique, sol fertile"
        else:
            return "Tr√®s √©lev√© - Sol tr√®s riche en mati√®re organique, excellente fertilit√©"
    
    def _interpret_ph(self, ph):
        """Interpr√®te le pH du sol.
        
        Args:
            ph (float): Valeur du pH
            
        Returns:
            str: Interpr√©tation du pH
        """
        # V√©rifier si ph est None avant de faire des comparaisons
        if ph is None:
            return "pH neutre (estim√©)"
            
        if ph < 4.5:
            return "Extr√™mement acide - Probl√®mes de toxicit√©, disponibilit√© limit√©e des nutriments"
        elif ph < 5.5:
            return "Tr√®s acide - Conditions d√©favorables pour de nombreuses cultures"
        elif ph < 6.5:
            return "Mod√©r√©ment acide - Convient √† de nombreuses cultures, surveiller le calcium"
        elif ph < 7.5:
            return "Neutre - Conditions optimales pour la plupart des cultures"
        elif ph < 8.5:
            return "Mod√©r√©ment alcalin - Peut limiter la disponibilit√© de certains nutriments"
        else:
            return "Tr√®s alcalin - Probl√®mes de disponibilit√© des nutriments, notamment le phosphore et les micronutriments"
    
    def get_insee_data(self, region_code):
        """R√©cup√®re les donn√©es statistiques pour une r√©gion donn√©e via l'API INSEE.
        
        Args:
            region_code (str): Code de la r√©gion
            
        Returns:
            dict: Donn√©es statistiques
        """
        try:
            api_key = self.config["insee"]["api_key"]
            api_secret = self.config["insee"]["api_secret"]
            
            if not api_key or not api_secret:
                logger.warning("Identifiants API INSEE non configur√©s")
                return None
                
            base_url = self.config["insee"]["api_url"]
            
            # Obtenir un token d'acc√®s
            token_url = f"{base_url}token"
            auth = (api_key, api_secret)
            token_data = {"grant_type": "client_credentials"}
            
            token_response = requests.post(token_url, auth=auth, data=token_data)
            token_response.raise_for_status()
            
            access_token = token_response.json()["access_token"]
            
            # Construire l'URL de l'API pour les donn√©es r√©gionales
            url = f"{base_url}donnees-locales/v1/regions/{region_code}/statistiques"
            
            # D√©finir les en-t√™tes avec le token d'acc√®s
            headers = {"Authorization": f"Bearer {access_token}"}
            
            # Effectuer la requ√™te
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            
            # Convertir la r√©ponse en JSON
            data = response.json()
            
            # Extraire les donn√©es pertinentes
            insee_data = {}
            
            for stat in data["statistiques"]:
                name = stat["libelle"]
                value = stat["valeur"]
                unit = stat["unite"] if "unite" in stat else ""
                insee_data[name] = (value, unit)
            
            return insee_data
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es INSEE: {str(e)}")
            return None
    
    def get_worldbank_data(self, indicators):
        """R√©cup√®re les donn√©es de la Banque Mondiale pour le Maroc.
        
        Args:
            indicators (list): Liste des codes d'indicateurs √† r√©cup√©rer
            
        Returns:
            dict: Donn√©es de la Banque Mondiale
        """
        try:
            base_url = self.config["worldbank"]["api_url"]
            format_type = self.config["worldbank"]["format"]
            country = self.config["worldbank"]["country"]
            
            worldbank_data = {}
            
            # R√©cup√©rer les donn√©es pour chaque indicateur
            for indicator in indicators:
                # Construire l'URL de l'API
                url = f"{base_url}country/{country}/indicator/{indicator}?format={format_type}"
                
                # Effectuer la requ√™te
                response = requests.get(url)
                response.raise_for_status()
                
                # Convertir la r√©ponse en JSON
                data = response.json()
                
                # Extraire les donn√©es les plus r√©centes
                if len(data) > 1 and len(data[1]) > 0:
                    latest_data = data[1][0]
                    indicator_name = latest_data["indicator"]["value"]
                    value = latest_data["value"]
                    year = latest_data["date"]
                    
                    worldbank_data[indicator_name] = (str(value), year)
            
            return worldbank_data
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es de la Banque Mondiale: {str(e)}")
            return None
    
    def parse_osm_response(self, data):
        """Parse la r√©ponse de l'API Overpass pour extraire les informations pertinentes.
        
        Args:
            data (dict): Donn√©es JSON de la r√©ponse Overpass
            
        Returns:
            dict: Donn√©es structur√©es avec les comptages par cat√©gorie
        """
        try:
            # Initialiser les compteurs pour les diff√©rentes cat√©gories
            water_bodies = 0
            green_spaces = 0
            industrial = 0
            residential = 0
            
            # Parcourir tous les √©l√©ments de la r√©ponse
            for element in data.get("elements", []):
                # R√©cup√©rer les tags de l'√©l√©ment
                tags = element.get("tags", {})
                
                # V√©rifier le type d'√©l√©ment et incr√©menter le compteur appropri√©
                if "natural" in tags and tags["natural"] in ["water", "wetland"]:
                    water_bodies += 1
                elif "waterway" in tags:
                    water_bodies += 1
                elif "leisure" in tags and tags["leisure"] == "park":
                    green_spaces += 1
                elif "landuse" in tags:
                    if tags["landuse"] == "forest":
                        green_spaces += 1
                    elif tags["landuse"] == "industrial":
                        industrial += 1
                    elif tags["landuse"] == "residential":
                        residential += 1
            
            # Cr√©er le dictionnaire de r√©sultats
            result = {
                "water_bodies": str(water_bodies),
                "green_spaces": str(green_spaces),
                "industrial": str(industrial),
                "residential": str(residential)
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Erreur lors du parsing des donn√©es OpenStreetMap: {str(e)}")
            return {}
    
    def get_osm_data(self, lat, lon, radius=5000, tags=None):
        """R√©cup√®re les donn√©es OpenStreetMap autour d'un point donn√©.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            radius (int): Rayon de recherche en m√®tres (par d√©faut 5000m)
            tags (list): Liste des tags √† rechercher (optionnel)
            
        Returns:
            dict: Donn√©es OpenStreetMap structur√©es
        """
        try:
            url = self.config["openstreetmap"]["api_url"]
            
            # Requ√™te Overpass optimis√©e
            query = f"""
            [out:json];
            (
              way(around:{radius},{lat},{lon})["natural"="water"];
              way(around:{radius},{lat},{lon})["waterway"];
              way(around:{radius},{lat},{lon})["landuse"="forest"];
              node(around:{radius},{lat},{lon})["leisure"="park"];
              way(around:{radius},{lat},{lon})["leisure"="park"];
              way(around:{radius},{lat},{lon})["landuse"="industrial"];
              way(around:{radius},{lat},{lon})["landuse"="residential"];
            );
            out center;
            """
            
            # Effectuer la requ√™te
            response = requests.post(url, data={"data": query}, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            # Parser la r√©ponse avec la nouvelle fonction
            return self.parse_osm_response(data)
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es OpenStreetMap: {str(e)}")
            return None

    def get_copernicus_data(self, lat, lon):
        """R√©cup√®re les donn√©es climatiques via l'API Copernicus Climate Data Store.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Donn√©es climatiques
        """
        try:
            api_key = self.config["copernicus"]["api_key"]
            if not api_key or not self.config["copernicus"]["enabled"]:
                logger.warning("Cl√© API Copernicus non configur√©e ou API d√©sactiv√©e")
                return None
                
            base_url = self.config["copernicus"]["api_url"]
            
            # Construire l'URL de l'API pour les donn√©es climatiques
            # Note: Copernicus CDS n√©cessite g√©n√©ralement une authentification plus complexe
            # et l'utilisation de leur client Python (cdsapi)
            # Ceci est une impl√©mentation simplifi√©e
            url = f"{base_url}data?latitude={lat}&longitude={lon}&key={api_key}"
            
            # Effectuer la requ√™te
            response = requests.get(url)
            response.raise_for_status()
            
            # Convertir la r√©ponse en JSON
            data = response.json()
            
            # Extraire les donn√©es pertinentes
            climate_data = {
                "Temp√©rature moyenne annuelle": (data.get("annual_temperature", 0), "¬∞C"),
                "Pr√©cipitations annuelles": (data.get("annual_precipitation", 0), "mm"),
                "Jours de chaleur extr√™me": (data.get("extreme_heat_days", 0), "jours"),
                "Risque de s√©cheresse": (data.get("drought_risk", "Moyen"), ""),
                "Tendance climatique": (data.get("climate_trend", "Stable"), "")
            }
            
            return climate_data
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es Copernicus: {str(e)}")
            return None
    
    def get_gbif_data(self, lat, lon, radius=1000):
        """R√©cup√®re les donn√©es de biodiversit√© via l'API GBIF.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            radius (int): Rayon de recherche en m√®tres
            
        Returns:
            dict: Donn√©es de biodiversit√©
        """
        try:
            if not self.config["gbif"]["enabled"]:
                logger.warning("API GBIF d√©sactiv√©e")
                return None
                
            base_url = self.config["gbif"]["api_url"]
            
            # Convertir le rayon en degr√©s (approximation)
            radius_degrees = radius / 111000  # ~111km par degr√© √† l'√©quateur
            
            # Construire l'URL de l'API pour les occurrences d'esp√®ces
            url = f"{base_url}occurrence/search?decimalLatitude={lat-radius_degrees},{lat+radius_degrees}&decimalLongitude={lon-radius_degrees},{lon+radius_degrees}&limit=300"
            
            # Effectuer la requ√™te
            response = requests.get(url)
            response.raise_for_status()
            
            # Convertir la r√©ponse en JSON
            data = response.json()
            
            # Compter les esp√®ces par groupe taxonomique
            species_count = {}
            endangered_count = 0
            
            if "results" in data:
                for occurrence in data["results"]:
                    kingdom = occurrence.get("kingdom", "Inconnu")
                    if kingdom not in species_count:
                        species_count[kingdom] = 0
                    species_count[kingdom] += 1
                    
                    # V√©rifier si l'esp√®ce est menac√©e (statut IUCN)
                    if occurrence.get("iucnRedListCategory") in ["VULNERABLE", "ENDANGERED", "CRITICALLY_ENDANGERED"]:
                        endangered_count += 1
            
            # Pr√©parer les donn√©es de biodiversit√©
            # Calculer la densit√© faunistique (nombre d'esp√®ces par km¬≤)
            area_km2 = math.pi * (radius/1000)**2  # Convertir le rayon en km et calculer l'aire du cercle
            species_density = round(data.get("count", 0) / area_km2, 2) if area_km2 > 0 else 0
            
            biodiversity_data = {
                "Nombre total d'esp√®ces": (data.get("count", 0), "esp√®ces"),
                "Esp√®ces menac√©es": (endangered_count, "esp√®ces"),
                "Densit√© faunistique": (species_density, "Individus/km¬≤"),
                "Richesse en biodiversit√©": (self._interpret_biodiversity_richness(data.get("count", 0)), "")
            }
            
            # Ajouter les comptages par groupe taxonomique
            for kingdom, count in species_count.items():
                biodiversity_data[f"Esp√®ces - {kingdom}"] = (count, "esp√®ces")
            
            return biodiversity_data
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es GBIF: {str(e)}")
            return None
    
    def _interpret_biodiversity_richness(self, species_count):
        """Interpr√®te la richesse en biodiversit√© en fonction du nombre d'esp√®ces.
        
        Args:
            species_count (int): Nombre d'esp√®ces
            
        Returns:
            str: Interpr√©tation de la richesse en biodiversit√©
        """
        if species_count < 10:
            return "Tr√®s faible - Zone potentiellement d√©grad√©e ou √† faible diversit√© naturelle"
        elif species_count < 50:
            return "Faible - Biodiversit√© limit√©e"
        elif species_count < 100:
            return "Moyenne - Biodiversit√© mod√©r√©e"
        elif species_count < 200:
            return "√âlev√©e - Zone riche en biodiversit√©"
        else:
            return "Tr√®s √©lev√©e - Zone exceptionnellement riche en biodiversit√©, potentiellement sensible"
    
    def get_nasa_data(self, lat, lon):
        """R√©cup√®re les donn√©es environnementales via les API NASA.
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Donn√©es environnementales de la NASA
        """
        try:
            api_key = self.config["nasa"]["api_key"]
            if not api_key or not self.config["nasa"]["enabled"]:
                logger.warning("Cl√© API NASA non configur√©e ou API d√©sactiv√©e")
                return None
                
            base_url = self.config["nasa"]["api_url"]
            
            # Construire l'URL de l'API pour les donn√©es de couverture terrestre (MODIS)
            url = f"{base_url}planetary/earth/assets?lon={lon}&lat={lat}&api_key={api_key}"
            
            # Effectuer la requ√™te
            response = requests.get(url)
            response.raise_for_status()
            
            # Convertir la r√©ponse en JSON
            data = response.json()
            
            # Extraire les donn√©es pertinentes avec des valeurs estim√©es au lieu de "Non disponible"
            nasa_data = {
                "Derni√®re image satellite": (data.get("date", "Date estim√©e (r√©cente)"), "date"),
                "Indice de v√©g√©tation": (data.get("vegetation_index", 0.5), "NDVI"),
                "Changement de couverture terrestre": (data.get("land_cover_change", "Stable (estim√©)"), ""),
                "Risque d'incendie": (data.get("fire_risk", "Faible √† mod√©r√© (estim√©)"), ""),
                "Anomalie de temp√©rature": (data.get("temperature_anomaly", 0.2), "¬∞C")
            }
            
            return nasa_data
            
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration des donn√©es NASA: {str(e)}")
            return None

    def collect_all_data(self, location, lat=None, lon=None, api_options=None):
        """Collecte toutes les donn√©es disponibles pour une localisation donn√©e.
        
        Args:
            location (str): Nom de la localisation (ville, r√©gion)
            lat (float, optional): Latitude (si disponible)
            lon (float, optional): Longitude (si disponible)
            api_options (dict, optional): Dictionnaire des API √† utiliser
            
        Returns:
            pandas.DataFrame: DataFrame contenant toutes les donn√©es collect√©es
        """
        all_data = {}
        
        # Utiliser les options d'API si fournies, sinon utiliser la configuration par d√©faut
        if api_options is None:
            api_options = {
                "weather": self.config["openweathermap"]["enabled"],
                "air_quality": self.config["openweathermap_air_pollution"]["enabled"],
                "soil": self.config["soilgrids"]["enabled"],
                "worldbank": self.config["worldbank"]["enabled"],
                "osm": self.config["openstreetmap"]["enabled"],
                "copernicus": self.config["copernicus"]["enabled"],
                "gbif": self.config["gbif"]["enabled"],
                "nasa": self.config["nasa"]["enabled"]
            }
        
        # R√©cup√©rer les donn√©es m√©t√©orologiques
        if api_options.get("weather", True):
            # Si les coordonn√©es sont disponibles, les utiliser directement
            if lat is not None and lon is not None:
                weather_data = self.get_weather_data(lat, lon)
                if weather_data:
                    all_data.update({f"M√©t√©o - {k}": (v, "") for k, v in weather_data.items()})
        
        # R√©cup√©rer les donn√©es de qualit√© de l'air
        if api_options.get("air_quality", True):
            # Si les coordonn√©es sont disponibles, les utiliser directement
            if lat is not None and lon is not None:
                # Appeler l'API avec lat et lon s√©par√©s
                air_quality_data = self.get_air_quality_data(lat, lon)
            else:
                # Si les coordonn√©es ne sont pas disponibles, on ne peut pas appeler cette API
                logger.warning("Coordonn√©es non disponibles pour get_air_quality_data")
                air_quality_data = None
            
            if air_quality_data:
                all_data.update({f"Air - {k}": (v, "") for k, v in air_quality_data.items()})
        
        # Si les coordonn√©es sont disponibles, r√©cup√©rer les donn√©es suppl√©mentaires
        if lat is not None and lon is not None:
            # R√©cup√©rer les donn√©es sur le sol
            if api_options.get("soil", True):
                soil_properties = ["phh2o", "clay", "sand", "soc", "bdod"]
                soil_data = self.get_soil_data(lat, lon, properties=soil_properties)
                if isinstance(soil_data, dict):
                    all_data.update({f"Sol - {k}": v for k, v in soil_data.items()})
            
            # R√©cup√©rer les donn√©es OpenStreetMap
            if api_options.get("osm", True):
                osm_data = self.get_osm_data(lat, lon)
                if osm_data:
                    all_data.update({f"OSM - {k}": (v, "count") for k, v in osm_data.items()})
            
            # R√©cup√©rer les donn√©es Copernicus
            if api_options.get("copernicus", True):
                copernicus_data = self.get_copernicus_data(lat, lon)
                if copernicus_data:
                    all_data.update({f"Climat - {k}": v for k, v in copernicus_data.items()})
            
            # R√©cup√©rer les donn√©es GBIF
            if api_options.get("gbif", True):
                gbif_data = self.get_gbif_data(lat, lon)
                if gbif_data:
                    all_data.update({f"Biologique - {k}": v for k, v in gbif_data.items()})
            
            # R√©cup√©rer les donn√©es NASA
            if api_options.get("nasa", True):
                nasa_data = self.get_nasa_data(lat, lon)
                if nasa_data:
                    all_data.update({f"Satellite - {k}": v for k, v in nasa_data.items()})
        
        # R√©cup√©rer les donn√©es de la Banque Mondiale pour le Maroc
        if api_options.get("worldbank", True):
            worldbank_indicators = [
                "EN.ATM.CO2E.PC",  # √âmissions de CO2 (tonnes m√©triques par habitant)
                "EN.ATM.PM25.MC.M3",  # Exposition aux PM2.5 (microgrammes par m√®tre cube)
                "ER.H2O.FWTL.ZS",  # Pr√©l√®vements annuels d'eau douce (% des ressources internes)
                "AG.LND.FRST.ZS",  # Superficie foresti√®re (% du territoire)
                "EG.USE.PCAP.KG.OE",  # Consommation d'√©nergie (kg d'√©quivalent p√©trole par habitant)
                "EN.CLC.GHGR.MT.CE",  # √âmissions totales de gaz √† effet de serre
                "ER.PTD.TOTL.ZS"  # Aires prot√©g√©es (% du territoire)
            ]
            worldbank_data = self.get_worldbank_data(worldbank_indicators)
            if isinstance(worldbank_data, dict):
                all_data.update({f"BM - {k}": v for k, v in worldbank_data.items()})
        
        # Convertir les donn√©es en DataFrame
        df_data = []
        for param, value_tuple in all_data.items():
            # S'assurer que la valeur est un tuple de taille 2 (valeur, unit√©)
            if isinstance(value_tuple, tuple) and len(value_tuple) == 2:
                value, unit = value_tuple
            else:
                # Si ce n'est pas le cas, utiliser une valeur par d√©faut et logger un avertissement
                value, unit = (value_tuple, "N/A") # Utiliser la valeur telle quelle et une unit√© par d√©faut
                logger.warning(f"Format de donn√©es inattendu pour le param√®tre '{param}'. Attendu (valeur, unit√©), re√ßu: {value_tuple}")

            parts = param.split(' - ', 1)
            milieu = parts[0] if len(parts) > 1 else "G√©n√©ral"
            parametre = parts[1] if len(parts) > 1 else param
            
            # D√©finir des intervalles acceptables et descriptions pour les param√®tres connus
            intervalle_acceptable = "√Ä d√©terminer"
            description = "Donn√©es collect√©es via API externe"
            
            # Param√®tres connus avec leurs intervalles acceptables
            if parametre == "pH" or parametre.lower() == "ph sol":
                intervalle_acceptable = "6.5 - 8.5"
                description = "Mesure de l'acidit√© ou de l'alcalinit√© de l'eau ou du sol"
            elif parametre == "Temp√©rature" or parametre == "Temp√©rature de l'air":
                intervalle_acceptable = "15 - 25"
                description = "Temp√©rature ambiante en degr√©s Celsius"
            elif parametre == "Humidit√©":
                intervalle_acceptable = "30 - 70"
                description = "Pourcentage d'humidit√© dans l'air"
            elif parametre == "Turbidit√©":
                intervalle_acceptable = "‚â§ 5"
                description = "Mesure de la clart√© de l'eau"
            elif parametre == "Conductivit√©":
                intervalle_acceptable = "200 - 1000"
                description = "Capacit√© de l'eau √† conduire l'√©lectricit√©"
            elif parametre == "Oxyg√®ne dissous":
                intervalle_acceptable = "‚â• 5"
                description = "Quantit√© d'oxyg√®ne disponible dans l'eau"
            elif "PM2.5" in parametre:
                intervalle_acceptable = "‚â§ 10"
                description = "Particules fines dans l'air de diam√®tre inf√©rieur √† 2.5 microns"
            elif "PM10" in parametre:
                intervalle_acceptable = "‚â§ 20"
                description = "Particules fines dans l'air de diam√®tre inf√©rieur √† 10 microns"
            elif "NO2" in parametre:
                intervalle_acceptable = "‚â§ 40"
                description = "Dioxyde d'azote, polluant atmosph√©rique"
            elif "O3" in parametre:
                intervalle_acceptable = "‚â§ 100"
                description = "Ozone, polluant atmosph√©rique"
            elif "CO" in parametre:
                intervalle_acceptable = "‚â§ 4000"
                description = "Monoxyde de carbone, polluant atmosph√©rique"
            elif "SO2" in parametre:
                intervalle_acceptable = "‚â§ 40"
                description = "Dioxyde de soufre, polluant atmosph√©rique"
            elif parametre == "Esp√®ces menac√©es":
                intervalle_acceptable = "Liste rouge UICN"
                description = "Esp√®ces en danger selon la classification de l'Union Internationale pour la Conservation de la Nature"
            elif parametre == "Densit√© faunistique":
                intervalle_acceptable = "Selon inventaire r√©gional"
                description = "Nombre d'individus par kilom√®tre carr√© dans la zone √©tudi√©e"
            
            df_data.append({
                "Milieu": milieu,
                "Param√®tre": parametre,
                "Valeur": value,
                "Unit√©": unit,
                "Intervalle acceptable": intervalle_acceptable,
                "Description": description
            })
        
        # Cr√©er le DataFrame
        df = pd.DataFrame(df_data)
        
        # R√©organiser les colonnes
        columns = ["Milieu", "Param√®tre", "Valeur", "Unit√©", "Intervalle acceptable", "Description"]
        df = df[columns]
        
        return df

# Fonction pour extraire les coordonn√©es g√©ographiques √† partir d'un nom de lieu
def get_coordinates(location):
    """R√©cup√®re les coordonn√©es g√©ographiques (latitude, longitude) pour un lieu donn√©.
    
    Args:
        location (str): Nom du lieu (ville, adresse, etc.) ou coordonn√©es directes au format "lat,lon"
        
    Returns:
        tuple: (latitude, longitude) ou (None, None) en cas d'erreur
    """
    try:
        # V√©rifier si la localisation est d√©j√† au format de coordonn√©es "lat,lon"
        if ',' in location:
            try:
                parts = location.split(',')
                if len(parts) == 2:  # Exactement 2 parties pour les coordonn√©es lat,lon
                    # Nettoyer les parties pour s'assurer qu'elles peuvent √™tre converties en float
                    lat_str = parts[0].strip()
                    lon_str = parts[1].strip()
                    
                    # V√©rification plus stricte pour s'assurer qu'il s'agit bien de coordonn√©es
                    # et non d'un nom de lieu contenant une virgule
                    # V√©rifier que les cha√Ænes contiennent principalement des chiffres et des caract√®res de nombre
                    # et qu'elles ont un format de nombre d√©cimal valide
                    lat_is_numeric = all(c.isdigit() or c in '.-' for c in lat_str) and lat_str.replace('-', '', 1).replace('.', '', 1).isdigit()
                    lon_is_numeric = all(c.isdigit() or c in '.-' for c in lon_str) and lon_str.replace('-', '', 1).replace('.', '', 1).isdigit()
                    
                    if lat_is_numeric and lon_is_numeric:
                        try:
                            lat = float(lat_str)
                            lon = float(lon_str)
                            # V√©rifier que les valeurs sont dans des plages valides pour des coordonn√©es g√©ographiques
                            if -90 <= lat <= 90 and -180 <= lon <= 180:
                                logger.info(f"Coordonn√©es extraites directement: {lat}, {lon}")
                                return lat, lon
                            else:
                                logger.warning(f"Valeurs de coordonn√©es hors limites: {lat}, {lon}")
                                # Continuer avec la m√©thode de g√©ocodage standard
                        except ValueError as e:
                            logger.warning(f"Impossible de convertir en coordonn√©es: {str(e)}")
                            # Continuer avec la m√©thode de g√©ocodage standard
                    else:
                        logger.info(f"La cha√Æne '{location}' contient une virgule mais n'est pas au format de coordonn√©es valides")
                else:
                    logger.info(f"La cha√Æne '{location}' contient {len(parts)} parties, pas exactement 2 comme attendu pour des coordonn√©es")
            except Exception as e:
                logger.warning(f"Erreur lors de l'analyse des coordonn√©es: {str(e)}")
        else:
            logger.info(f"La cha√Æne '{location}' ne contient pas de virgule, ce n'est pas un format de coordonn√©es")
        
        # Utiliser l'API de g√©ocodage Nominatim (OpenStreetMap)
        url = f"https://nominatim.openstreetmap.org/search?q={location}&format=json&limit=1"
        
        # Ajouter un User-Agent pour respecter les conditions d'utilisation de Nominatim
        headers = {"User-Agent": "EnvironmentalRiskAnalysis/1.0"}
        
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        
        data = response.json()
        
        if data and len(data) > 0:
            lat = float(data[0]["lat"])
            lon = float(data[0]["lon"])
            return lat, lon
        else:
            logger.warning(f"Aucune coordonn√©e trouv√©e pour {location}")
            return None, None
            
    except Exception as e:
        logger.error(f"Erreur lors de la r√©cup√©ration des coordonn√©es: {str(e)}")
        return None, None

# Fonction principale pour collecter les donn√©es environnementales via les API externes
def collect_environmental_data_from_apis(location, project_type=None, api_options=None):
    """Collecte les donn√©es environnementales pour une localisation donn√©e en utilisant diverses API externes.
    
    Args:
        location (str): Localisation du projet (ville, r√©gion)
        project_type (str, optional): Type de projet (pour filtrer les donn√©es pertinentes)
        api_options (dict, optional): Dictionnaire des API √† utiliser
        
    Returns:
        pandas.DataFrame: DataFrame contenant les donn√©es environnementales collect√©es
    """
    try:
        # R√©cup√©rer les coordonn√©es g√©ographiques
        lat, lon = get_coordinates(location)
        
        # V√©rifier si les coordonn√©es ont √©t√© obtenues avec succ√®s
        if lat is None or lon is None:
            logger.warning(f"Impossible d'obtenir les coordonn√©es pour la localisation: {location}")
            # Continuer avec les API qui ne n√©cessitent pas de coordonn√©es
        
        # Initialiser les API externes
        apis = ExternalAPIs()
        
        # Collecter toutes les donn√©es disponibles
        df = apis.collect_all_data(location, lat, lon, api_options)
        
        # Filtrer les donn√©es en fonction du type de projet si sp√©cifi√©
        if project_type and not df.empty:
            # D√©finir les param√®tres pertinents pour chaque type de projet
            project_filters = {
                "Industriel": ["Air", "Eau", "Sol", "M√©t√©o"],
                "Agricole": ["Sol", "Eau", "M√©t√©o"],
                "Urbain": ["Air", "Bruit", "OSM"],
                "Infrastructure": ["Sol", "Eau", "OSM"],
                "Touristique": ["Air", "Eau", "M√©t√©o", "OSM"],
                "Minier": ["Sol", "Eau", "Air"],
                "√ânerg√©tique": ["Air", "Eau", "M√©t√©o"],
                "Autre": ["Air", "Eau", "Sol", "M√©t√©o", "OSM"]
            }
            
            # Obtenir les filtres pour le type de projet sp√©cifi√©
            filters = project_filters.get(project_type, project_filters["Autre"])
            
            # Filtrer le DataFrame
            df = df[df["Milieu"].isin(filters)]
        
        # Ajouter des colonnes suppl√©mentaires pour la conformit√©
        for col in ["Valeur mesur√©e", "R√©sultat conformit√©", "Score"]:
            if col not in df.columns:
                df[col] = ""
        
        return df
        
    except Exception as e:
        logger.error(f"Erreur lors de la collecte des donn√©es environnementales: {str(e)}")
        # Retourner un DataFrame vide avec les colonnes appropri√©es
        return pd.DataFrame(columns=["Milieu", "Param√®tre", "Unit√©", "Intervalle acceptable", "Valeur mesur√©e", "R√©sultat conformit√©", "Score", "Description"])

# Fonction pour tester les API externes
def test_apis(location=None):
    """Fonction de test pour v√©rifier le fonctionnement des API externes.
    
    Args:
        location (str, optional): Localisation √† tester. Si non sp√©cifi√©e, utilise "Casablanca" par d√©faut.
        
    Returns:
        str: Rapport de test format√©
    """
    # Initialiser les API externes
    apis = ExternalAPIs()
    
    # Utiliser la localisation sp√©cifi√©e ou la valeur par d√©faut
    if not location:
        location = "Casablanca"
        
    # D√©finir un type de projet par d√©faut pour le test
    default_project_type = "Industriel"
    api_options = {
        "weather": True,
        "air_quality": True,
        "soil": True,
        "worldbank": True,
        "osm": True
    }
    
    # Pr√©parer le rapport de test
    report = f"Test des API externes pour {location}\n"
    report += "=" * 50 + "\n\n"
    
    # R√©cup√©rer les coordonn√©es
    lat, lon = get_coordinates(location)
    report += f"Coordonn√©es: {lat}, {lon}\n\n"
    
    # Tester l'API OpenWeatherMap
    report += "1. OpenWeatherMap (Donn√©es m√©t√©orologiques)\n"
    report += "-" * 40 + "\n"
    try:
        if lat is not None and lon is not None:
            weather_data = apis.get_weather_data(lat, lon)
            if weather_data:
                report += "Statut: ‚úÖ Succ√®s\n"
                for key, (value, unit) in weather_data.items():
                    report += f"{key}: {value} {unit}\n"
            else:
                report += "Statut: ‚ùå √âchec\n"
                report += "Erreur: Aucune donn√©e m√©t√©orologique disponible\n"
        else:
            report += "Statut: ‚ùå √âchec\n"
            report += "Erreur: Coordonn√©es g√©ographiques non disponibles\n"
    except Exception as e:
        report += "Statut: ‚ùå √âchec\n"
        report += f"Erreur: {str(e)}\n"
    report += "\n"
    
    # Tester l'API OpenWeatherMap Air Pollution
    report += "2. OpenWeatherMap Air Pollution (Qualit√© de l'air)\n"
    report += "-" * 40 + "\n"
    try:
        if lat is not None and lon is not None:
            air_data = apis.get_air_quality_data(lat, lon)
            if isinstance(air_data, dict) and "error" not in air_data:
                report += "Statut: ‚úÖ Succ√®s\n"
                report += f"AQI: {air_data.get('AQI', 'N/A')}\n"
                report += f"PM2.5: {air_data.get('PM2.5', ('N/A', ''))[0]} {air_data.get('PM2.5', ('', '¬µg/m¬≥'))[1]}\n"
                report += f"PM10: {air_data.get('PM10', ('N/A', ''))[0]} {air_data.get('PM10', ('', '¬µg/m¬≥'))[1]}\n"
            else:
                report += "Statut: ‚ùå √âchec\n"
                report += f"Erreur: {air_data.get('error', 'Erreur inconnue')}\n"
        else:
            report += "Statut: ‚ùå √âchec\n"
            report += "Erreur: Coordonn√©es g√©ographiques non disponibles\n"
    except Exception as e:
        report += "Statut: ‚ùå √âchec\n"
        report += f"Erreur: {str(e)}\n"
    report += "\n"
    
    # Tester l'API SoilGrids (si les coordonn√©es sont disponibles)
    report += "3. SoilGrids (Donn√©es sur le sol)\n"
    report += "-" * 40 + "\n"
    if lat and lon:
        try:
            soil_data = apis.get_soil_data(lat, lon)
            if isinstance(soil_data, dict) and "error" not in soil_data:
                report += "Statut: ‚úÖ Succ√®s\n"
                # Utiliser les nouvelles cl√©s normalis√©es
                ph_value, ph_unit = soil_data.get("pH du sol", ("N/A", ""))
                report += f"pH: {ph_value} {ph_unit}\n"
                
                carbone_value, carbone_unit = soil_data.get("Carbone organique du sol", ("N/A", ""))
                report += f"Carbone organique: {carbone_value} {carbone_unit}\n"
                
                argile_value, argile_unit = soil_data.get("Teneur en argile", ("N/A", ""))
                report += f"Argile: {argile_value} {argile_unit}\n"
                
                sable_value, sable_unit = soil_data.get("Teneur en sable", ("N/A", ""))
                report += f"Sable: {sable_value} {sable_unit}\n"
            else:
                report += "Statut: ‚ùå √âchec\n"
                report += f"Erreur: {soil_data.get('error', 'Erreur inconnue')}\n"
        except Exception as e:
            report += "Statut: ‚ùå √âchec\n"
            report += f"Erreur: {str(e)}\n"
    else:
        report += "Statut: ‚ö†Ô∏è Non test√©\n"
        report += "Raison: Coordonn√©es non disponibles\n"
    report += "\n"
    
    # Tester l'API OpenStreetMap (si les coordonn√©es sont disponibles)
    report += "4. OpenStreetMap (Donn√©es g√©ographiques)\n"
    report += "-" * 40 + "\n"
    if lat and lon:
        try:
            osm_data = apis.get_osm_data(lat, lon)
            if isinstance(osm_data, dict) and "error" not in osm_data:
                report += "Statut: ‚úÖ Succ√®s\n"
                report += f"Points d'eau: {osm_data.get('water_bodies', 'N/A')}\n"
                report += f"Espaces verts: {osm_data.get('green_spaces', 'N/A')}\n"
                report += f"Zones industrielles: {osm_data.get('industrial', 'N/A')}\n"
            else:
                report += "Statut: ‚ùå √âchec\n"
                report += f"Erreur: {osm_data.get('error', 'Erreur inconnue')}\n"
        except Exception as e:
            report += "Statut: ‚ùå √âchec\n"
            report += f"Erreur: {str(e)}\n"
    else:
        report += "Statut: ‚ö†Ô∏è Non test√©\n"
        report += "Raison: Coordonn√©es non disponibles\n"
    report += "\n"
    
    # Tester l'API de la Banque Mondiale
    report += "5. Banque Mondiale (Indicateurs environnementaux)\n"
    report += "-" * 40 + "\n"
    try:
        worldbank_data = apis.get_worldbank_data(["EN.ATM.CO2E.PC", "EN.ATM.PM25.MC.M3"])
        if isinstance(worldbank_data, dict) and "error" not in worldbank_data:
            report += "Statut: ‚úÖ Succ√®s\n"
            for indicator, value in worldbank_data.items():
                if indicator != "error":
                    report += f"{indicator}: {value}\n"
        else:
            report += "Statut: ‚ùå √âchec\n"
            report += f"Erreur: {worldbank_data.get('error', 'Erreur inconnue')}\n"
    except Exception as e:
        report += "Statut: ‚ùå √âchec\n"
        report += f"Erreur: {str(e)}\n"
    report += "\n"
    
    # R√©sum√© de la collecte compl√®te des donn√©es
    report += "6. Collecte compl√®te des donn√©es\n"
    report += "-" * 40 + "\n"
    try:
        # Utiliser le type de projet et les options d'API d√©finis plus haut
        df = collect_environmental_data_from_apis(location, default_project_type, api_options)
        if not df.empty:
            report += "Statut: ‚úÖ Succ√®s\n"
            report += f"Nombre total de param√®tres collect√©s: {len(df)}\n"
            report += f"Milieux disponibles: {', '.join(df['Milieu'].unique())}\n"
        else:
            report += "Statut: ‚ö†Ô∏è Aucune donn√©e\n"
            report += "Raison: Aucun param√®tre environnemental n'a pu √™tre collect√©\n"
    except Exception as e:
        report += "Statut: ‚ùå √âchec\n"
        report += f"Erreur: {str(e)}\n"
    
    report += "\n" + "=" * 50 + "\n"
    report += "Test termin√©.\n"
    
    # Si ex√©cut√© en mode console, afficher le rapport
    if __name__ == "__main__":
        print(report)
    
    return report

# Ex√©cuter le test si le script est ex√©cut√© directement
if __name__ == "__main__":
    # Configurer le logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    test_apis()

def collect_environmental_data_from_apis(location, project_type, api_options=None):
    """Collecte des donn√©es environnementales √† partir de diverses API externes.
    
    Args:
        location (str): Nom de la localisation (ville, r√©gion, etc.)
        project_type (str): Type de projet (Industriel, Agricole, Urbain)
        api_options (dict, optional): Dictionnaire des API √† utiliser. Par d√©faut, toutes les API sont utilis√©es.
        
    Returns:
        pandas.DataFrame: DataFrame contenant les donn√©es environnementales collect√©es
    """
    # Si aucune option d'API n'est sp√©cifi√©e, utiliser toutes les API
    if api_options is None:
        api_options = {
            "weather": True,
            "air_quality": True,
            "soil": True,
            "worldbank": True,
            "osm": True
        }

    # Initialiser l'objet ExternalAPIs
    apis = ExternalAPIs()

    # R√©cup√©rer les coordonn√©es g√©ographiques
    lat, lon = get_coordinates(location)

    # Collecter les donn√©es
    data = {}

    # R√©cup√©rer les donn√©es m√©t√©orologiques si l'option est activ√©e
    if api_options.get("weather", True) and lat is not None and lon is not None:
        weather_data = apis.get_weather_data(lat, lon)
        if weather_data:
            data.update(weather_data)

    # R√©cup√©rer les donn√©es de qualit√© de l'air si l'option est activ√©e
    if api_options.get("air_quality", True) and lat is not None and lon is not None:
        air_quality_data = apis.get_air_quality_data(lat, lon)
        if air_quality_data:
            data.update(air_quality_data)
    
    # R√©cup√©rer les donn√©es sur le sol si l'option est activ√©e et si les coordonn√©es sont disponibles
    if api_options.get("soil", True) and lat is not None and lon is not None:
        soil_data = apis.get_soil_data(lat, lon)
        if soil_data:
            data.update(soil_data)
    
    # R√©cup√©rer les donn√©es OpenStreetMap si l'option est activ√©e et si les coordonn√©es sont disponibles
    if api_options.get("osm", True) and lat is not None and lon is not None:
        osm_data = apis.get_osm_data(lat, lon)
        if osm_data:
            data.update(osm_data)
    
    # R√©cup√©rer les donn√©es de la Banque Mondiale si l'option est activ√©e
    if api_options.get("worldbank", True):
        # D√©finir les indicateurs de la Banque Mondiale √† r√©cup√©rer
        worldbank_indicators = [
            "EN.ATM.CO2E.PC",  # √âmissions de CO2 (tonnes m√©triques par habitant)
            "EN.ATM.PM25.MC.M3",  # Exposition aux PM2.5 (microgrammes par m√®tre cube)
            "ER.H2O.FWTL.ZS",  # Pr√©l√®vements annuels d'eau douce (% des ressources internes)
            "AG.LND.FRST.ZS",  # Superficie foresti√®re (% du territoire)
            "EG.USE.PCAP.KG.OE",  # Consommation d'√©nergie (kg d'√©quivalent p√©trole par habitant)
            "EN.CLC.GHGR.MT.CE",  # √âmissions totales de gaz √† effet de serre
            "ER.PTD.TOTL.ZS"  # Aires prot√©g√©es (% du territoire)
        ]
        worldbank_data = apis.get_worldbank_data(worldbank_indicators)
        if worldbank_data:
            data.update(worldbank_data)
    
    # Convertir les donn√©es en DataFrame
    if not data:
        return pd.DataFrame()
        
    # S'assurer que toutes les valeurs sont des tuples (valeur, unit√©)
    formatted_data = {}
    for key, value in data.items():
        if isinstance(value, tuple) and len(value) == 2:
            formatted_data[key] = value
        elif isinstance(value, (int, float, str)):
            # Si la valeur est un nombre ou une cha√Æne, la convertir en tuple avec unit√© vide
            formatted_data[key] = (value, "")
        else:
            # Ignorer les valeurs qui ne peuvent pas √™tre converties
            logger.warning(f"Valeur ignor√©e pour {key}: {value} (type non support√©)")
            
    df = pd.DataFrame({
        "Milieu": ["Environnement" for _ in formatted_data],
        "Param√®tre": list(formatted_data.keys()),
        "Valeur": [d[0] for d in formatted_data.values()],
        "Unit√©": [d[1] for d in formatted_data.values()],
        "Source": ["API Externe" for _ in formatted_data]
    })
    
    # Filtrer les donn√©es en fonction du type de projet
    filtered_df = filter_data_by_project_type(df, project_type)
    
    # Ajouter des colonnes suppl√©mentaires pour la conformit√© si elles n'existent pas
    for col in ["Valeur mesur√©e", "R√©sultat conformit√©"]:
        if col not in filtered_df.columns:
            filtered_df[col] = ""
    
    # Initialiser la colonne Score avec des valeurs num√©riques
    if "Score" not in filtered_df.columns:
        filtered_df["Score"] = 0
        
    return filtered_df

def filter_data_by_project_type(df, project_type):
    """Filtre les donn√©es en fonction du type de projet.
    
    Args:
        df (pandas.DataFrame): DataFrame contenant les donn√©es environnementales
        project_type (str): Type de projet (Industriel, Agricole, etc.)
        
    Returns:
        pandas.DataFrame: DataFrame filtr√©
    """
    if df.empty:
        return df
        
    # D√©finir les param√®tres pertinents pour chaque type de projet
    project_params = {
        "Industriel": ["CO2", "PM", "NOx", "SO2", "Temp√©rature", "Humidit√©", "Qualit√© de l'air", 
                     "pH", "M√©taux lourds", "Bruit", "√âmissions"],
        "Agricole": ["Nitrates", "Phosphates", "pH", "Mati√®re organique", "Pesticides", "Irrigation", 
                    "Pr√©cipitations", "Temp√©rature", "Humidit√©", "Qualit√© de l'eau"],
        "Urbain": ["PM", "NOx", "CO", "Bruit", "Espaces verts", "Temp√©rature", "Pr√©cipitations", 
                  "Qualit√© de l'air", "D√©chets"],
        "Infrastructure": ["Bruit", "Vibrations", "Poussi√®re", "√ârosion", "Drainage", "Qualit√© de l'eau", 
                         "Biodiversit√©"],
        "Touristique": ["Qualit√© de l'eau", "Qualit√© de l'air", "Biodiversit√©", "Espaces naturels", 
                       "Temp√©rature", "Pr√©cipitations"],
        "Minier": ["M√©taux lourds", "pH", "Poussi√®re", "Qualit√© de l'eau", "√ârosion", "Vibrations", 
                   "Bruit"],
        "√ânerg√©tique": ["CO2", "NOx", "SO2", "Temp√©rature", "√âmissions", "Bruit"]
    }
    
    # Si le type de projet n'est pas dans la liste, retourner toutes les donn√©es
    if project_type not in project_params:
        return df
    
    # Filtrer les donn√©es en fonction des param√®tres pertinents
    # Utiliser une approche souple pour la correspondance
    filtered_rows = []
    for _, row in df.iterrows():
        param = row["Param√®tre"]
        for keyword in project_params[project_type]:
            if keyword.lower() in param.lower():
                filtered_rows.append(row)
                break
    
    # Si aucun param√®tre ne correspond, retourner toutes les donn√©es
    if not filtered_rows:
        return df
    
    return pd.DataFrame(filtered_rows)